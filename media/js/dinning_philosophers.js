/**
 * dinning_philosophers.js was generated by Jesse's Joomla MVC component generator,
 * as part of the com_dinning_philosophers project.
 *
 * @author    Jesse Riggs
 * @copyright 2021 Jesse Riggs
 * @license   GNU General Public License version 2 or later;see LICENSE.txt
 */

function dinning_philosophersDemo(evt, input) {

	var dinning_philosophersElement =
		document.getElementById("dinning-philosophers-element");
	dinning_philosophersElement.style.backgroundColor = "black";

}

// first we need to create a stage
var stage = new Konva.Stage({
	container : 'dinning-philosophers-element',   // id of container <div>
	width     : 1265,
	height    : 720
});

// then create layer
var layer = new Konva.Layer();

const pName = [
	'void',
	'Nietzsche',
	'Sun Tzu',
	'Machiavelli'
];

const COLORS = {
	'background' : '#333333',
	'READY'      : '#dbdb33',
	'READY_T'    : '#dbdb33',
	'SLEEP'      : '#888',
	'SLEEP_T'    : '#666',
	'RUNNING'    : '#88db33',
	'RUNNING_T'  : '#88db33',
	'ENDED'      : '#888',
	'ENDED_T'    : '#666',
	'ERROR'      : '#db3333',
	'ERROR_T'    : '#db3333',
	'text'       : '#e8e8e8',
	'textH'      : '#33e833',
	'marinara'   : '#e83333',
	'noodles'    : '#e8e833',
	'meatball'   : '#b55533',
	'chopstick'  : '#555',
	'conBG'      : '#333333',
};

/**
 * Philosopher runs spaghetti eating algorithms.
 * @author Jesse Riggs
 * @version 1
 */
class Philosopher
{
	constructor( id, codebox, avatar ){
		this.pid      = id;
		this.status   = 'READY';
		this.pc       = 1;
		this.finished = false;
		this.codebox  = codebox;
		this.avatar   = avatar;
	}

	run(){
		this.status = 'RUNNING';
		this.prog();
		this.drawChanges();
	}

	prog(){
		this.pc++;
	}

	setStatus( s ){
		this.status = s;
		this.avatar.setStatus( s );
		this.codebox.setStatus( s );
		this.codebox.makeBold( this.pc, COLORS[ s ] );
	}

	stop(){
		if(this.finished)
			return;
		this.setStatus( 'READY' );
	}

	sleep( redraw = false ){
		if( this.finished ) return;
		this.setStatus( 'SLEEP' );
		if( redraw ) layer.draw();
	}

	end(){
		this.finished = true;
		this.pc       = 13;
		this.setStatus( 'ENDED' );
		layer.draw();
	}

	drawChanges(){
		if( this.finished ) return;
		this.setStatus( 'RUNNING' );
		layer.draw();
	}

	ERROR(){
		if(!this.finished){
			this.setStatus( 'ERROR' );
		}
	}

	makeBold( id )
	{
		let colorH = COLORS.textH;
		if( this.status == 'READY' )
			colorH = COLORS.READY_T;
		else if( this.status == 'SLEEP' )
			colorH = COLORS.SLEEP_T;
		else if( this.status == 'ENDED' )
			colorH = COLORS.SLEEP_T;
		this.codebox.makeBold( id, colorH );
	}

	getLeft(){
		return this.pid;
	}

	getRight(){
		if( this.pid == 1 ) return 3;
		return ( this.pid - 1 );
	}

	wait( chopstick ){
		var id = '#c' + chopstick + 'label';
		var txt = 'C' + chopstick + ': ' + pName[ this.pid ];
		stage.find( id ).text( txt );
	}

	post( chopstick ){
		var id = '#c' + chopstick + 'label';
		var txt = 'C' + chopstick + ':';
		stage.find( id ).text( txt );
	}

	eat(){
		var cleft = '#c' + this.getLeft();
		stage.find( cleft ).stroke( COLORS.RUNNING );
		stage.find( cleft + 'label' ).fill( COLORS.RUNNING );
		var cright = '#c' + this.getRight();
		stage.find( cright ).stroke( COLORS.RUNNING );
		stage.find( cright + 'label').fill( COLORS.RUNNING );
		this.avatar.eat();
	}

	finishEating(){
		var cleft = '#c' + this.getLeft();
		stage.find( cleft ).stroke( COLORS.SLEEP );
		stage.find( cleft + 'label' ).fill( COLORS.meatball );
		var cright = '#c' + this.getRight();
		stage.find( cright ).stroke( COLORS.SLEEP );
		stage.find( cright + 'label' ).fill( COLORS.meatball );
		this.avatar.finishEating();
	}

}

function makeText( x, y, str, id )
{
	return new Konva.Text({
		x          : x,
		y          : y,
		text       : str,
		id         : 'prog'+id,
		fontSize   : 14,
		fontFamily : 'Lucida Console, Courier, monospace',
		fill       : COLORS.text,
		width      : 400,
		padding    : 20,
	});
}

var sn=0;
function runNextCommand()
{
    switch( sn )
    {
        case 0:
            ph1.run();
	    sn++;
	    break;
	case 1:
	    ph1.stop();
	    ph2.run();
	    sn++;
	    break;
	case 2:
	    ph2.stop();
	    ph3.run();
	    sn++;
	    break;
	case 3:
	    ph3.stop();
	    // Nietzsche reaches right.
	    ph1.wait( ph1.getRight() );
	    ph1.run();
	    sn++;
	    break;
	case 4:
	    ph1.stop();
	    // Sun Tsu reaches left.
	    ph2.wait( ph2.getLeft() );
	    ph2.run();
	    sn++;
	    break;
	case 5:
	    ph2.stop();
	    // Machiavelli reaches left but C3 alREADY held by Nietzsche.
	    ph3.run();
	    sn++;
	    break;
	case 6:
	    // So, Machiavelli goes to sleep.
	    ph3.sleep( true );
	    sn++;
	    break;
	case 7:
	    // Now, Nietzsche can reach left.
	    ph1.wait( ph1.getLeft() );
	    ph1.run();
	    sn++;
	    break;
	case 8:
	    // Sun Tzu reaches for C1 which is alREADY held by Nietzsche.
	    ph1.stop();
	    ph2.run();
	    sn++;
	    break;
	case 9:
	    // So, Sun Tzu goes to sleep.
	    ph2.sleep( true );
	    sn++;
	    break;
	case 10:
	    // Thus ate Zarathustra.
	    ph1.run();
	    sn++;
	    break;
	case 11:
	    // Nietzsche posts right chopstick. Machiavelli is awoken.
	    ph1.post( ph1.getRight() );
	    ph3.stop();
	    ph1.run();
	    sn++;
	    break;
	case 12:
	    // Machievelli reaches for left chopstick.
	    ph1.stop();
	    ph3.wait( ph3.getLeft() );
	    ph3.run();
	    sn++;
	    break;
	case 13:
	    // Machiavelli sleeps.
	    ph3.sleep( true );
	    sn++;
	    break;
	case 14:
	    // Nietzsche posts left chopstick, which awakens Sun Tsu.
	    ph1.post( ph1.getLeft() );
	    ph2.stop();
	    ph1.run();
	    sn++;
	    break;
	case 15:
	    // To the victory comes to the great general
	    ph1.stop();
	    ph2.wait( ph2.getRight() );
	    ph2.run();
	    sn++;
	    break;
	case 16:
	    ph2.stop();
	    ph1.end();
	    sn++;
	    break;
	case 17:
	    // Sun Tsu posts chopstick
	    ph2.post( ph2.getRight() );
	    ph2.run();
	    sn++;
	    break;
	case 18:
	    // Sun Tsu posts chopstick to Machiavelli
	    ph2.post( ph2.getLeft() );
	    ph3.stop();
	    ph2.run();
	    sn++;
	    break;
	case 19:
	    // Machiavelli takes it.
	    ph2.stop();
	    ph3.wait( ph3.getRight() );
	    // The prince finally obtains his crown
	    ph3.run();
	    sn++;
	    break;
	case 20:
	    ph3.stop();
	    ph2.end();
	    sn++;
	    break;
	case 21:
	    ph3.post( ph3.getRight() );
	    ph3.run();
	    sn++;
	    break;
	case 22:
	    ph3.post( ph3.getLeft() );
	    ph3.run();
	    sn++;
	    break;
	case 23:
	    ph3.end();
	    sn++;
	    break;
	default :
	    break;
    }
}

//
// Code boxes
//
function codeBox( x, y, width, height, id )
{
	var box = new Konva.Rect({
		x             : x,
		y             : y,
		id            : "prec" + id,
		stroke        : COLORS.SLEEP,
		strokeWidth   : 5,
		fill          : COLORS.conBG,
		width         : width,
		height        : height,
		shadowColor   : COLORS.conBG,
		shadowBlur    : 2,
		shadowOffsetX : 1,
		shadowOffsetY : 1,
		cornerRadius  : 10,
	});
	layer.add( box );

	return box;
}
function solutionCodeBox( x, y, id )
{
	return codeBox( x, y, 400, 280, id );
}

//
// This will go at the top of the codebox.
//
function philosopherTitle( x, y, pid )
{
	var pT = new Konva.Text({
		x              : x,
		y              : y,
		text           : pName[ pid ] + "\n" ,
		fontSize       : 18,
		fontFamily     : 'Lucida Console, Courier, monospace',
		fontStyle      : 'bold',
		textDecoration : 'underline',
		fill           : COLORS.text,
		width          : 300,
		padding        : 20,
	});
	layer.add( pT );

	return pT;
}

//
// Codebox statuses
//
function codeStatus( x, y, id )
{
	var s = new Konva.Text({
		x             : x,
		y             : y,
		id            : 'pstat' + id,
		text          : 'STATUS=READY',
		fontSize      : 28,
		fontFamily    : 'Lucida Console, Courier, monospace',
		fontStyle     : 'bold',
		fill          : COLORS.SLEEP,
		stroke        : COLORS.conBG,
		strokeWidth   : 0.4,
		shadowColor   : COLORS.conBG,
		shaodwOffsetX : 1,
		shadowOffsetY : 1,
		shadowBlur    : 1,
	});
	layer.add( s );

	return s;
}

class CodeBox
{
	constructor(
			x      = 0,
			y      = 0,
			width  = 300,
			height = 100,
			id     = 0,
			code   = []
		)
	{
		this.code    = [];
		this.console = codeBox( x, y, width, height, id );
		this.title   = philosopherTitle( x, y, id );
		this.status  = codeStatus( ( x + 10 ), ( y - 30 ), id );
		for( let i=0; i< code.length; i++ ){
			let t = makeText(
					x,
					80 + i * 20,
					code[ i ],
					'' + id + ( i + 1 )
				);
			this.code.push( t );
			layer.add( t );
		}
	}

	makeBold( ln, colorH = COLORS.textH )
	{
		for( let i = 1; i <= 12; i++ ){
			let ltxt = this.code[ i - 1 ];
			ltxt.strokeWidth( 0.7 );
			if( i != ln ){
				ltxt.stroke( 'transparent' );
				ltxt.fill( COLORS.text );
				ltxt.textDecoration( '' );
				ltxt.fontStyle( 'normal' );
			}
			else{
				ltxt.stroke( colorH );
				ltxt.fill( colorH );
				ltxt.textDecoration( 'underline' );
				ltxt.fontStyle( 'bold' );
			}
		}
	}

	setStatus( s )
	{
		this.console.stroke( COLORS[s] );
		this.status.fill( COLORS[ s + '_T' ] );
		this.status.text( "STATUS=" + s );
	}

}

const SolutionCode = [
	" 1. void after_thinking(philosopher *p){" ,
	" 2.  if(p->isNietzsche){",
	" 3.   sem_wait(chopstick(right(p)));",
	" 4.   sem_wait(chopstick(left(p)));",
	" 5.  }else{",
	" 6.   sem_wait(chopstick(left(p)));" ,
	" 7.   sem_wait(chopstick(right(p)));",
	" 8.  }" ,
	" 9.  eat(p);",
	"10.  sem_post(chopstick(right(p)));" ,
	"11.  sem_post(chopstick(left(p)));" ,
	"12. }"
];
class SolutionCodeBox extends CodeBox
{
	constructor( id )
	{
		var width  = 400;
		var height = 280;
		var x      = id * 20 + ( id - 1 ) * width;
		var y      = 60;

		super( x, y, width, height, id, SolutionCode );
	}
}

//
// spaghetti
//
noodles = new Konva.Circle({
	radius: 60,
	fill: COLORS.noodles,
	x: 600,
	y: 550,
	stroke: COLORS.text,
	strokeWidth: 5,
	shadowColor: COLORS.conBG,
	shadowBlur: 2,
	shadowOffsetX: 1,
	shadowOffsetY: 1,
});
layer.add( noodles );

marinara = new Konva.Circle({
	radius: 30,
	fill: COLORS.marinara,
	x: 600,
	y: 550,
});
layer.add( marinara );

function meatball( x, y )
{
	var m = new Konva.Circle({
		radius        : 15,
		fill          : COLORS.meatball,
		x             : x,
		y             : y,
		shadowColor   : COLORS.conBG,
		shadowBlur    : 2,
		shadowOffsetX : 1,
		shadowOffsetY : 1,
	});
	layer.add( m );

	return m;
}
meatball( 570, 550 );
meatball( 630, 550 );
meatball( 600, 580 );
meatball( 600, 520 );

//
// chopsticks
//
function chopstick( x, y, id, rotation)
{
	var s = [ new Konva.Line({
			offset        : { x : 0, y : -45 },
			id            : 'c' + id,
			x             : x,
			y             : y,
			points        : [ 0, 0, 0, 60 ],
			stroke        : COLORS.chopstick,
			strokeWidth   : 5,
			shadowColor   : COLORS.conBG,
			shadowBlur    : 2,
			shadowOffsetX : 1,
			shadowOffsetY : 1,
		}).rotate( rotation ),
		new Konva.Text({
			x          : x,
			y          : y,
			id         : 'c' + id + 'label',
			text       : 'C' + id + ':',
			fontSize   : 18,
			fontFamily : 'Calibri',
			fontStyle  : 'normal',
			fill       : COLORS.meatball,
		}).rotate( 90 ).offset( { x : -65, y : -5 } ).rotate( rotation )
	];
	layer.add( s[ 0 ] );
	layer.add( s[ 1 ] );

	return s;
}
chopstick( 600, 550, 1,  120 );
chopstick( 600, 550, 2, -120 );
chopstick( 600, 550, 3,    0 );

//
// old farts
//
function avatar( id, rotation )
{
	var a = [ new Konva.Circle({
			id            : 'phil' + id,
			radius        : 45,
			fill          : COLORS.SLEEP,
			x             : 600,
			y             : 550,
			offset        : { x: 0, y: 120 },
			stroke        : COLORS.SLEEP,
			strokeWidth   : 5,
			shadowColor   : COLORS.conBG,
			shadowBlur    : 2,
			shadowOffsetX : 1,
			shadowOffsetY : 1,
			}).rotate( rotation ),
		new Konva.Text({
			id         : 'phil' + id + 'text',
			x          : 600,
			y          : 550,
			offset     : { x : 35, y : 185 },
			text       : pName[ id ],
			fontSize   : 18,
			fontFamily : 'Lucida Console, Courier, monospace',
			fontStyle  : 'bold',
			fill       : COLORS.conBG,
		}).rotate( rotation )
	];
	layer.add( a[ 0 ] );
	layer.add( a[ 1 ] );

	return a;
}
class Avatar
{
	constructor( id )
	{
		var rot = 120 * ( id - 1 ) - 120;
		[ this.body, this.name ] = avatar( id, rot );
	}

	setStatus( s )
	{
		this.body.stroke( COLORS[ s ] );
	}

	eat()
	{
		this.name.fill( COLORS.RUNNING );
	}

	finishEating()
	{
		this.name.fill( COLORS.conBG );
	}
}

class SolutionPhilosopher extends Philosopher
{
	constructor( id )
	{
		var cb = new SolutionCodeBox( id );
		var av = new Avatar( id );
		super( id, cb, av );
	}

	prog()
	{
		// the only place we really care about is the conditional.
		if( ( this.pc == 2 ) && ( this.pid != 1 ) ) this.pc += 3;
		else if ( this.pc == 4 ) {
			this.pc += 4;
		} else if ( this.pc == 7 ) {
			this.pc++;
		}

		this.pc++;

		// have we stopped at food?
		if( this.pc == 9 )
			this.eat();
		else if( this.pc == 10 )
			this.finishEating();
	}
}
var ph1 = new SolutionPhilosopher( 1 );
var ph2 = new SolutionPhilosopher( 2 );
var ph3 = new SolutionPhilosopher( 3 );

// add the layer to the stage
stage.add(layer);

ph1.stop();
ph2.stop();
ph3.stop();

// Draw image
layer.draw();

/* vim: set tabstop=4 */
